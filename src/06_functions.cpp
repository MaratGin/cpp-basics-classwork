// Исходный код программы на С++.

#include <iostream>
#include <tuple>

// 1. "определение" функции без входных параметров и возвращаемого значения
void do_nothing() {
  // здесь находится тело функции
}

// 2. "определение" функции с 1 входным параметром без возвращаемого значения
void do_nothing(int arg) {

  if (arg > 10) {
    return;  // "завершаем" выполнение функции
  }

  // тело функции
}

// 3. "объявление" функции (тело функции не определено)
int do_something();

// Заметка: main вызывается автоматически при запуске программы (исполняемого файла).
int main() {

  // Вызов функций.

  // Вызов функций осуществляется оператором "круглые скобки" ().
  // При наличии аргументов, они передаются внутрь скобок.

  do_nothing();  // 1

  do_nothing(12);  // 2

  int ret = do_something();  // 3

  return 0;  // оператор "завершения вызова" функции
}

// 3. "определение" ранее объявленной функции
int do_something() {
  return 3;
}

void task_one(int a, int b) {
  int c = a + b;
}

std::tuple<int, int> task_two() {
  int a = 5;
  int b = 10;
  return std::make_tuple(a, b);  // возвращаем tuple
}

/*
 * Задания:
 * 1. Определите функцию, которая ничего не возвращает и принимает два входных параметра.
 * A: функиця task_one()
 * 2. Определите функцию, которая возвращает два и более значения (tuple). Возможно ли это?
 * A: Да, для этого пришлось сделать include <tuple> (Функция task_two()) 
 * 3. В чем разница между "объявлением" и "определением" функции?
 * Объявление функции — это информация о функции, предоставленная компилятору, но не содержит тела функции
 * Определение функции включает в себя не только объявление, но и реализацию функции 
 * 4. Какая функция запускается вне зависимости от того, вызываем ли мы ее?
 *  int main() {}
 * 5. Поразмыслите, что происходит с данными, которые передаются в функцию: копирование, ссылка?
 * Поведение зависит от того, как именно мы передаём данные в функцию:
 * По значению: компилятор создаёт копию значения аргумента
 * По ссылке: в функцию передаётся не копия данных, а ссылка на исходную переменную
 * любые изменения, сделанные с переменной внутри функции, отразятся и на саму переменную void test(int& x) {}
 * По указателю: Примерно та же логика, что и в случае со ссылкой, 
 * но нужно явно указать указатель void test(int* x) {}
 */